#!/bin/bash

#
# ********** DONT RUN THIS UNLESS YOU UNDERSTAND WHAT IT DOES ********
# **********             SERIOUS DAMAGE MAY OCCUR             ********
#
# Generate and publish src built packages for $PRODUCTs and their dependencies
#
# $ src-publish [-b <build_id>] [-t <distservtag>] [product1 [product2 [...]]]
#
# Example:
#    'publish -t current' will publish the build found in $LSSTSW_BUILD_DIR
#    and tag it as 'current' on the distribution server
#
# ------------------------------------------------------------------------
# the publish is done in 2 steps:
# 1- the packages are published in a local TMP_PKGROOT
#      TMP_PKGROOT is set to a folder inside lsstsw and cleaned before each use
# 2- the packages are published to the EUPS_PKGROOT
#      EUPS_PKGREPO shall be defined in the environemnt where the script is executed
#      it can be:
#      - a local folder (used mainly for debug) 
#      - a remote aws s3 bucket
#      The packages will be publish to ${EUPS_PKGREPO}/stack/src


DISTRIBTAG=
BUILD=

set -e
DIR=$(cd "$(dirname "$0")"; pwd)
# shellcheck disable=SC1090
. "${DIR}/../etc/settings.cfg.sh"

TMP_PKGROOT=$LSSTSW/tmp_distrib

usage() { echo "Usage: $0 [-b <build_id>] [-t <distservtag>] <product1> [product2 [...]]" 1>&2; exit 1; }

run() {
  if [[ $DRYRUN == true ]]; then
    echo "$@"
  elif [[ $DEBUG == true ]]; then
    (set -x; "$@")
  else
    "$@"
  fi
}


print_settings() {
  local vars=(
    BUILD
    DISTRIBTAG
    DEBUG
    LSSTSW
    LSSTSW_BUILD_DIR
  )

  # print env vars prefixed with ^EUPS
  IFS=" " read -r -a eups_vars <<< "${!EUPS@}"
  vars+=("${eups_vars[@]}")

  for i in ${vars[*]}
  do
    echo "${i}: ${!i}"
  done
}


# -------    main
timestamp=$(date '+%Y%m%d%H%M%S')

while getopts ":b:t:d" o; do
  case "$o" in
  b)
    BUILD="$OPTARG"
    ;;
  t)
    DISTRIBTAG="$OPTARG"
    ;;
  d)
    DEBUG=true
    ;;
  *)
    usage
    ;;
  esac
done
shift $((OPTIND-1))

if [[ $# -eq 0 ]]; then
  usage
fi

if [[ -z $BUILD ]]; then
  # retriving buildID from manifest.txt
  BUILD=$(grep '^BUILD=' $LSSTSW/build/manifest.txt | awk -F '=' '{print $2}')
fi

if [[ -z $DISTRIBTAG ]] || [[ $DISTRIBTAG == "" ]]; then
  # set DISTRIBTAG equal to buildID
  DISTRIBTAG="${timestamp}"
fi
echo "[publish-src] Distribution Tag identification $DISTRIBTAG."

# once the buildID is givem the environment name can be identified
LSST_CONDA_ENV_NAME=$(grep -E '^environment_name:' "${LSSTSW}/build/builds/${BUILD}.env" | awk '{print $2}')
ENVREF="${LSST_CONDA_ENV_NAME#${SPLENV_BASE_NAME}-}"
CONDA_ENV_REF="${LSST_SPLENV_REPO}@${LSST_CONDA_ENV_NAME#${SPLENV_BASE_NAME}-}"
echo
echo "[publish-src] $LSST_CONDA_ENV_NAME used for build $BUILD (envref $ENVREF)."
echo

# activating the environment it has been used for the build
source $LSSTSW/bin/envconfig -n $LSST_CONDA_ENV_NAME

# rmpty local pkgroot
run rm -rf "${TMP_PKGROOT}"

PRODUCTS=("$@")

for prod in "${PRODUCTS[@]}"; do
  if [[ -z "$prod" ]]; then
    echo "zero length product names are not permitted"
    usage
  fi
  if [[ $prod == *[[:space:]]* ]]; then
    echo "white spaces are not permitted in product names"
    usage
  fi
done

if [[ $DEBUG == true ]]; then
	cat <<-EOF
	----------------------------------------------------------------
	$(print_settings)
	----------------------------------------------------------------
	EOF
fi

#
# Create the distribution packages
#
for product in "${PRODUCTS[@]}"; do
  echo "[publish-src] Preparing tag '$DISTRIBTAG' (sources) for product ${product}."
  mkdir -p "${TMP_PKGROOT}/${product}"/tags
  # echo eups distrib create --server-dir="$TMP_PKGROOT" -f generic -d eupspkg -t "$BUILD" "$product"
  run eups distrib create --server-dir="$TMP_PKGROOT/${product}" -f generic -d eupspkg -t "$BUILD" "$product"
  # 
  run eups distrib declare --server-dir="$TMP_PKGROOT/$product" -t "$BUILD"
  echo "[publish-src] Adding tag '$DISTRIBTAG' at the distribution server."
  match='EUPS distribution ([^ ]+) version list. Version 1.0'
  # shellcheck disable=SC1117
  sub="EUPS distribution ${DISTRIBTAG} version list. Version 1.0\n#BUILD=\1\n#CONDA_ENV=${CONDA_ENV_REF}"
  src_tag="${TMP_PKGROOT}/${product}/tags/${BUILD}.list"
  dst_tag="${TMP_PKGROOT}/${product}/tags/${DISTRIBTAG}.list"
  #
  run sed -r "s|${match}|${sub}|" "$src_tag" > "$dst_tag"
  #
  # remove the original bNNNN tag to reduce tag proliferation
  rm "$src_tag"
done

## -- ignored for the moment
## Publish the newinstall script, if declared current
##
#if [[ $DISTRIBTAG == current ]] && eups list -t "$BUILD" lsst >/dev/null 2>&1; then
#  echo "Copying newinstall.sh to the distribution server."
#  run cp -a "$(eups list -t "$BUILD" -d lsst)/bin/newinstall.sh" "${EUPS_PKGROOT}/"
#fi


if [[ ! -z $EUPS_PKGREPO ]]; then
  # push to final PKGROOT enabled
  for product in "${PRODUCTS[@]}"; do
    deploy_destination="stack/$product/src/"
    echo "[publish-src] Publishing to filesystem: ${EUPS_PKGREPO}"
    if [[ "${EUPS_PKGREPO:0:4}" != "http" ]]; then
      # the PKGROOT is a local filesystem
      run cp -r "${TMP_PKGROOT}/${product}/." "${EUPS_PKGREPO}/stack/src/"
    else
      # the PKGROOT is a remote aws s3
      echo "To Be Implemented."
    fi
  done
else
  echo "[publish-src] No Publishing."
fi 

# vim: tabstop=2 shiftwidth=2 expandtab
